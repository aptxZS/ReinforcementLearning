% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[toc,page]{appendix}
\usepackage{listings}
\usepackage{color}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
%  frame=single,
  breaklines=true,
}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Reinforcement learning - Lab 1}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Dimitri Diomaiuta - 30598109}
%
% \authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Southampton}
%% \institute{Princeton University, Princeton NJ 08544, USA \and
%% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
%% \email{lncs@springer.com}\\
%% \url{http://www.springer.com/gp/computer-science/lncs} \and
%% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
%% \email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
%% \begin{abstract}
%% Searching is one of the oldest artificial intelligence techniques used for problem solving. In this paper we analyze the results and scalability of both uninformed and informed search algorithms.
%% %\keywords{First keyword  \and Second keyword \and Another keyword.}
%% \end{abstract}
%
%
%

\section{Fibonacci numbers}
Fibonacci numbers are a mathematical sequence which values are
determined by the recurrence relation \ref{fibonaccieq}
\cite{fib_num}.
\begin{equation}\label{fibonaccieq}
  F_n=\begin{cases}
  0 & \text{if $n=0$}.\\
  1 & \text{if $n=1$}.\\
  F_{n-1} + F_{n-2} & \text{otherwise}.
  \end{cases}
\end{equation}
The calculation of the fibonacci sequence shows the optimal
substructure property. This means that the end result can be seen as a
composition of solving subproblems of the same type using the same
procedure. A plain recursion approach will generate, in the winding
phase, a recursive tree of subproblems until the problem cannot be
decomposed any further (the leaves of the tree). In the unwinding
phase the generated solution of the subproblems are combined to solve
a bigger subproblem. The solution is calculated when all the
subproblems are solved and combined together. We can observe a
recursion tree of the fifth fibonacci sequence number in figure \ref{fig1}.
\begin{figure}
\includegraphics[width=\textwidth]{recursion.png}
\caption{Recursion tree of fibonacci sequence calculation} \label{fig1}
\end{figure}
The recursion generates and traverses the tree as a depth first search
algorithm. We can observe from figure \ref{fig1} that the very same
subproblems are generated and solved multiple times. We can observe
that the subtrees that have a gray node as root have already been
computed \cite{fibo}. The dynamic programming paradigm solves exactly
this kind of problem by exploiting memoization of the partial
solutions \cite{dprogramming}. When a subproblem is solved its
solution is cached and reused once the same subproblem occurs. The
dynamic programming optimization drastically improves the complexity
time. The plain recursion approach runs in exponential time complexity,
$O(2^n)$, while the dynamic programming method has a linear time
complexity, $O(n)$ \cite{fibo}. The space complexity of both the algorithms is
linear, $O(n)$, since the tree is traversed in a depth first search
like manner. The code of both methods can be seen in subsection
\ref{graph_code} of appendix\ref{appendix}.

\section{Shortest path problem}
The shortest path problem is another type of problem that has the
optimal substructure property \cite{dijkstra}. The Dijkstra's
algorithm is one of the most used algorithms for the purpose of
calculating the shortest path between a source and a target
node. Splitting the shortest path problem in subproblems results in
calculating the shortest paths between the source node and the nodes
that stand in the way to reach the target node. Following the dynamic
programming approach, Dijkstra algorithm uses memoization to store the
solutions of the subproblems. In this section we extended the
described algorithm to calculate the shortest paths for all the nodes
in a graph. Each node is visited in an iterative manner and the
subproblem solutions are stored in a matrix. We tested the program on
a 100 nodes graph with uniform cost connections (path cost 1) with
different probabilities of occurrence. Figures \ref{hist1},
\ref{hist2} \ref{hist3} and \ref{hist4} show the shortest pairwise
distances distribution under different probability distributions. As
we can observe from the histograms, the higher the probability of
connecting the shortest the path between each node is. 
The code of the program can be seen in subsection \ref{graph_code} of
appendix \ref{appendix}.
\begin{figure}
\includegraphics[width=\textwidth]{img/hist1.png}
\caption{Histogram of shortest pairwise distances for probability 0.02
and 0.05} \label{hist1}
\end{figure}
\begin{figure}
\includegraphics[width=\textwidth]{img/hist2.png}
\caption{Histogram of shortest pairwise distances for probability 0.08
and 0.1} \label{hist2}
\end{figure}
\begin{figure}
\includegraphics[width=\textwidth]{img/hist3.png}
\caption{Histogram of shortest pairwise distances for probability 0.2
and 0.3} \label{hist3}
\end{figure}
\begin{figure}
\includegraphics[width=\textwidth]{img/hist4.png}
\caption{Histogram of shortest pairwise distances for probability 0.5
and 0.7} \label{hist4}
\end{figure}

\section{Mountain car}
Mountain car shit
\begin{itemize}
\item Explain what type of reinforcement learning problem this is
  (continous problem rendered as discrete to exploit the Q-table)
\item Explain what happens when changing the exploration rate
\item Show plots to support the claims
\end{itemize}


\begin{thebibliography}{8}

\bibitem{rlbook}
Sutton, R.S. and Barto, A.G., 2011. Reinforcement learning: An introduction.

\bibitem{dprogramming}
En.wikipedia.org. (2019). Dynamic programming. [online] Available at: \url{https://en.wikipedia.org/wiki/Dynamic\_programming} [Accessed 16 Feb. 2019].

\bibitem{fibo}
Weibel, D. (2019). Recursion and Dynamic Programming. [online] Weibeld.net. Available at: \url{http://weibeld.net/algorithms/recursion.html} [Accessed 16 Feb. 2019].

\bibitem{fib_num}
En.wikipedia.org. (2019). Fibonacci number. [online] Available at: \url{https://en.wikipedia.org/wiki/Fibonacci\_number} [Accessed 16 Feb. 2019].

\bibitem{dijkstra}
Sniedovich, M., 2006. Dijkstra's algorithm revisited: the dynamic programming connexion. Control and cybernetics, 35(3), pp.599-620.

\end{thebibliography}


\section{Appendix A: source code}\label{appendix}
This appendix section contains the source code of the implemented programs.

\subsection{fibonacci.py}\label{fibonacci_code}
\lstinputlisting[language=Python]{../fibonacci.py}

\subsection{graph.py}\label{graph_code}
\lstinputlisting[language=Python]{../graph.py}

\end{document}
