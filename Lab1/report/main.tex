% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[toc,page]{appendix}
\usepackage{listings}
\usepackage{color}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
%  frame=single,
  breaklines=true,
}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Reinforcement learning - Lab 1}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Dimitri Diomaiuta - 30598109}
%
% \authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Southampton}
%% \institute{Princeton University, Princeton NJ 08544, USA \and
%% Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
%% \email{lncs@springer.com}\\
%% \url{http://www.springer.com/gp/computer-science/lncs} \and
%% ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
%% \email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
%% \begin{abstract}
%% Searching is one of the oldest artificial intelligence techniques used for problem solving. In this paper we analyze the results and scalability of both uninformed and informed search algorithms.
%% %\keywords{First keyword  \and Second keyword \and Another keyword.}
%% \end{abstract}
%
%
%

\section{Fibonacci numbers}
Fibonacci numbers are a mathematical sequence which values are
determined by the recurrence relation \ref{fibonaccieq}
\cite{fib_num}.
\begin{equation}\label{fibonaccieq}
  F_n=\begin{cases}
  0 & \text{if $n=0$}.\\
  1 & \text{if $n=1$}.\\
  F_{n-1} + F_{n-2} & \text{otherwise}.
  \end{cases}
\end{equation}
The calculation of the fibonacci sequence shows the optimal
substructure property. This means that the end result can be seen as a
composition of solving subproblems of the same type using the same
procedure. A plain recursion approach will generate, in the winding
phase, a recursive tree of subproblems until the problem cannot be
decomposed any further (the leaves of the tree). In the unwinding
phase the generated solution of the subproblems are combined to solve
a bigger subproblem. The solution is calculated when all the
subproblems are solved and combined together. We can observe a
recursion tree of the fifth fibonacci sequence number in figure \ref{fig1}.
\begin{figure}
\includegraphics[width=\textwidth]{recursion.png}
\caption{Recursion tree of fibonacci sequence calculation} \label{fig1}
\end{figure}
The recursion generates and traverses the tree as a depth first search
algorithm. We can observe from figure \ref{fig1} that the very same
subproblems are generated and solved multiple times. We can observe
that the subtrees that have a gray node as root have already been
computed \cite{fibo}. The dynamic programming paradigm solves exactly
this kind of problem by exploiting memoization of the partial
solutions \cite{dprogramming}. When a subproblem is solved its
solution is cached and reused once the same subproblem occurs. The
dynamic programming optimization drastically improves the complexity
time. The plain recursion approach runs in exponential time complexity,
$O(2^n)$, while the dynamic programming method has a linear time
complexity, $O(n)$. The space complexity of both the algorithms is
linear, $O(n)$, since the tree is traversed in a depth first search
like manner. The code of both methods can be seen in subsection
\ref{fibonacci_code} of appendix\ref{appendix}.

\section{Graph search}
Graph search shit
\begin{itemize}
\item Describe what is the purpose of using dynamic programming to
  calculate shortes path
\item Show plots of histograms distribution of node distances (how
  many steps are taken to reach the other nodes)
\end{itemize}

\section{Mountain car}
Mountain car shit
\begin{itemize}
\item Explain what type of reinforcement learning problem this is
  (continous problem rendered as discrete to exploit the Q-table)
\item Explain what happens when changing the exploration rate
\item Show plots to support the claims
\end{itemize}


\begin{thebibliography}{8}

\bibitem{rlbook}
Sutton, R.S. and Barto, A.G., 2011. Reinforcement learning: An introduction.

\bibitem{dprogramming}
En.wikipedia.org. (2019). Dynamic programming. [online] Available at: \url{https://en.wikipedia.org/wiki/Dynamic\_programming} [Accessed 16 Feb. 2019].

\bibitem{fibo}
Weibel, D. (2019). Recursion and Dynamic Programming. [online] Weibeld.net. Available at: \url{http://weibeld.net/algorithms/recursion.html} [Accessed 16 Feb. 2019].

\bibitem{fib_num}
En.wikipedia.org. (2019). Fibonacci number. [online] Available at: \url{https://en.wikipedia.org/wiki/Fibonacci\_number} [Accessed 16 Feb. 2019].

\end{thebibliography}


\section{Appendix A: source code}\label{appendix}
This appendix section contains the source code of the implemented programs.

\subsection{fibonacci.py}\label{fibonacci_code}
\lstinputlisting[language=Python]{../fibonacci.py}

\end{document}
